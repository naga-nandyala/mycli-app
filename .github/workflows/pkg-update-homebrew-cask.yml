name: PKG Distribution(cask) - Update Homebrew

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to update cask for (e.g., 1.0.0). Leave empty to use latest release.'
        required: false
        type: string
      force_format_refresh:
        description: 'Force commit even if same version/content (adds timestamp comment)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      always_commit:
        description: 'Always create a commit (even if unchanged) by appending a timestamp comment'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

permissions:
  contents: write

jobs:
  update-cask:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
            fetch-depth: 0

      - name: Determine version
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
            VERSION=${VERSION#v}
          elif [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=$(gh release list --limit 10 --json tagName,publishedAt --jq 'sort_by(.publishedAt) | reverse | .[0].tagName')
            VERSION=${VERSION#v}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Using version: $VERSION"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Download release .pkg files
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          echo "Downloading .pkg assets for version $VERSION"
          gh release download "v$VERSION" --pattern "*.pkg"
          ls -la *.pkg || true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Calculate SHA256 checksums
        id: shas
        run: |
          set -e
          ARM64_PKG=$(find . -maxdepth 1 -name '*.pkg' | grep -E '(arm64|aarch64)\.pkg$' | head -1)
          X86_64_PKG=$(find . -maxdepth 1 -name '*.pkg' | grep -E 'x86_64\.pkg$' | head -1)

          if [ -z "$ARM64_PKG" ] || [ -z "$X86_64_PKG" ]; then
            echo "Could not locate both architecture .pkg files" >&2
            echo "Available files:"
            ls -la *.pkg || true
            exit 1
          fi

          ARM64_SHA=$(shasum -a 256 "$ARM64_PKG" | cut -d' ' -f1)
          X86_64_SHA=$(shasum -a 256 "$X86_64_PKG" | cut -d' ' -f1)
          echo "arm64_filename=$(basename "$ARM64_PKG")" >> $GITHUB_OUTPUT
          echo "x86_64_filename=$(basename "$X86_64_PKG")" >> $GITHUB_OUTPUT
          echo "arm64_sha=$ARM64_SHA" >> $GITHUB_OUTPUT
          echo "x86_64_sha=$X86_64_SHA" >> $GITHUB_OUTPUT
          echo "ARM64 ($ARM64_PKG) -> $ARM64_SHA"
          echo "x86_64 ($X86_64_PKG) -> $X86_64_SHA"

      - name: Checkout Homebrew tap repository
        uses: actions/checkout@v4
        with:
          repository: naga-nandyala/homebrew-mycli-app
          token: ${{ secrets.HOMEBREW_TAP_TOKEN || secrets.GITHUB_TOKEN }}
          path: homebrew-tap

      - name: Update / Create PKG Cask file
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          ARM64_SHA="${{ steps.shas.outputs.arm64_sha }}"
          X86_64_SHA="${{ steps.shas.outputs.x86_64_sha }}"
          ARM64_FILE="${{ steps.shas.outputs.arm64_filename }}"
          X86_FILE="${{ steps.shas.outputs.x86_64_filename }}"

          cd homebrew-tap
          mkdir -p Casks

          # Write cask file using echo to avoid any heredoc line wrapping issues
          {
            echo "# NOTE: Auto-generated by workflow in mycli-app repo. Do not edit manually."
            echo "cask \"mycli-app-pkg\" do"
            echo "  version \"__VERSION__\""
            echo ""
            echo "  on_arm do"
            echo "    sha256 \"__ARM64_SHA__\""
            echo "    url \"https://github.com/naga-nandyala/mycli-app/releases/download/v#{version}/__ARM64_FILE__\""
            echo "  end"
            echo ""
            echo "  on_intel do"
            echo "    sha256 \"__X64_SHA__\""
            echo "    url \"https://github.com/naga-nandyala/mycli-app/releases/download/v#{version}/__X64_FILE__\""
            echo "  end"
            echo ""
            echo "  name \"MyCLI App (PKG Installer)\""
            echo "  desc \"Azure CLI-style tool for cloud operations with native macOS installer\""
            echo "  homepage \"https://github.com/naga-nandyala/mycli-app\""
            echo ""
            echo "  # PKG installer approach"
            echo "  pkg \"mycli-app-#{version}-#{Hardware::CPU.arch}.pkg\""
            echo ""
            echo "  # Binary will be installed to /usr/local/bin/mycli by the pkg installer"
            echo "  binary \"/usr/local/bin/mycli\""
            echo ""
            echo "  # Uninstall options"
            echo "  uninstall script: {"
            echo "    executable: \"/usr/local/bin/mycli-uninstall.sh\","
            echo "    sudo:       true"
            echo "  }"
            echo ""
            echo "  # Postflight verification"
            echo "  postflight do"
            echo "    system_command \"/usr/local/bin/mycli\", args: [\"--version\"]"
            echo "  end"
            echo ""
            echo "  # Additional info for users"
            echo "  caveats <<~EOS"
            echo "    MyCLI App has been installed system-wide to /usr/local/bin/mycli"
            echo "    "
            echo "    Usage:"
            echo "      mycli --help      # Show help"
            echo "      mycli --version   # Show version  "
            echo "      mycli login       # Login to Azure"
            echo "      mycli status      # Check status"
            echo "    "
            echo "    To uninstall:"
            echo "      sudo mycli-uninstall.sh"
            echo "    "
            echo "    Note: This version uses a native macOS .pkg installer for better"
            echo "    system integration and security compliance."
            echo "  EOS"
            echo "end"
          } > Casks/mycli-app-pkg.rb

          # Substitute placeholders
          sed -i "s/__VERSION__/$VERSION/g" Casks/mycli-app-pkg.rb
          sed -i "s/__ARM64_SHA__/$ARM64_SHA/g" Casks/mycli-app-pkg.rb
          sed -i "s/__X64_SHA__/$X86_64_SHA/g" Casks/mycli-app-pkg.rb
          # Substitute actual filenames found in the release
          sed -i "s/__ARM64_FILE__/$ARM64_FILE/g" Casks/mycli-app-pkg.rb
          sed -i "s/__X64_FILE__/$X86_FILE/g" Casks/mycli-app-pkg.rb

          # If forcing refresh, append a timestamp comment so there is a diff
          if [ "${{ github.event.inputs.force_format_refresh }}" = "true" ]; then
            echo "# Regenerated: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> Casks/mycli-app-pkg.rb
          fi

          # Sanity check: ensure "cask \"mycli-app-pkg\" do" is on a single line
          if ! grep -q '^ *cask "mycli-app-pkg" do$' Casks/mycli-app-pkg.rb; then
            echo 'ERROR: cask header malformed after substitution:' >&2
            grep -n 'cask "mycli-app-pkg"' Casks/mycli-app-pkg.rb || true
            echo 'Full file:'
            sed -n '1,40p' Casks/mycli-app-pkg.rb
            exit 1
          fi

          # Quick validation: ensure required placeholders got replaced
          if grep -q '__ARM64_SHA__' Casks/mycli-app-pkg.rb || grep -q '__X64_SHA__' Casks/mycli-app-pkg.rb; then
            echo 'ERROR: Not all SHA placeholders replaced'; sed -n '1,80p' Casks/mycli-app-pkg.rb; exit 1;
          fi

          # Ruby syntax check after placeholder substitution
          ruby -c Casks/mycli-app-pkg.rb || { echo 'Ruby syntax invalid for cask after substitution'; sed -n '1,120p' Casks/mycli-app-pkg.rb; exit 1; }

          echo "Generated cask file:" && head -40 Casks/mycli-app-pkg.rb

      - name: Show pending diff (for debugging)
        run: |
          cd homebrew-tap
          # Add as intent-to-add so diff shows if new
          git add -N Casks/mycli-app-pkg.rb || true
          echo "--- BEGIN DIFF ---"
          git diff --color=always Casks/mycli-app-pkg.rb || true
          echo "--- END DIFF ---"

      - name: Commit & push cask update
        run: |
          cd homebrew-tap
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"
          VERSION="${{ steps.get_version.outputs.version }}"
          # Stage file (again, safe even if already staged)
          git add Casks/mycli-app-pkg.rb
          if git diff --cached --quiet; then
            if [ "${{ github.event.inputs.always_commit }}" = "true" ]; then
              echo "No diff but always_commit=true -> appending timestamp comment to force commit";
              echo "# Recommit: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> Casks/mycli-app-pkg.rb
              git add Casks/mycli-app-pkg.rb
            elif [ "${{ github.event.inputs.force_format_refresh }}" = "true" ]; then
              echo "Force refresh requested but still no diff (unexpected). Showing file head:";
              head -30 Casks/mycli-app-pkg.rb; exit 0;
            else
              echo "No changes to commit (cask already up to date for version $VERSION)";
              exit 0;
            fi
          fi
          echo "Committing updated cask for version $VERSION"
          git commit -m "Update cask mycli-app-pkg to version $VERSION (auto-generated)"
          git push origin main
          echo "âœ… Cask updated and pushed"
        env:
          GITHUB_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN || secrets.GITHUB_TOKEN }}