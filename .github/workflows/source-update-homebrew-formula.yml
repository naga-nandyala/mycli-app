name: src style Installation - Update Homebrew Formula

# This workflow automatically updates the Homebrew formula for source-based installation
# when a new release is published or when manually triggered.
# This workflow is specifically designed for the source-based approach which builds from
# source code and manages dependencies through Homebrew's virtualenv system.
#
# Authentication: Uses HOMEBREW_TAP_TOKEN secret (Personal Access Token) for cross-repository access.
# If HOMEBREW_TAP_TOKEN is not available, falls back to GITHUB_TOKEN (limited permissions).

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to update formula for (e.g., 1.0.0). Leave empty to use latest release.'
        required: false
        type: string

permissions:
  contents: write

jobs:
  update-formula:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout main repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
      
    - name: Get release information
      id: get_release
      run: |
        if [ "${{ github.event_name }}" = "release" ]; then
          VERSION="${{ github.event.release.tag_name }}"
          VERSION=${VERSION#v}  # Remove 'v' prefix if present
        elif [ -n "${{ github.event.inputs.version }}" ]; then
          VERSION="${{ github.event.inputs.version }}"
        else
          # Get latest release by published date
          VERSION=$(gh release list --limit 10 --json tagName,publishedAt --jq 'sort_by(.publishedAt) | reverse | .[0].tagName')
          VERSION=${VERSION#v}  # Remove 'v' prefix if present
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Using version: $VERSION"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Calculate source tarball SHA256 hash
      id: calculate_hash
      run: |
        VERSION="${{ steps.get_release.outputs.version }}"
        
        # Download the source tarball from GitHub
        SOURCE_URL="https://github.com/naga-nandyala/mycli-app/archive/refs/tags/v${VERSION}.tar.gz"
        echo "Downloading source tarball from: $SOURCE_URL"
        
        curl -L -o "mycli-app-${VERSION}.tar.gz" "$SOURCE_URL"
        
        # Calculate SHA256 hash
        SOURCE_SHA=$(shasum -a 256 "mycli-app-${VERSION}.tar.gz" | cut -d' ' -f1)
        
        echo "Source SHA256: $SOURCE_SHA"
        
        # Set output
        echo "source_sha=$SOURCE_SHA" >> $GITHUB_OUTPUT
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Get Python dependency information
      id: get_dependencies
      run: |
        # Install Python and required tools
        python3 -m pip install --upgrade pip requests tomli
        
        # Create a script to fetch dependency information from PyPI
        cat > get_deps.py << 'EOF'
        import requests
        import json
        import sys
        import tomli
        import re
        import subprocess
        import tempfile
        import os
        from pathlib import Path
        
        def parse_pyproject_toml():
            """Parse pyproject.toml to extract dependencies"""
            try:
                with open('pyproject.toml', 'rb') as f:
                    data = tomli.load(f)
                
                dependencies = []
                packages_with_extras = []
                
                # Get main dependencies
                main_deps = data.get('project', {}).get('dependencies', [])
                print(f"üìã Found main dependencies: {main_deps}", file=sys.stderr)
                for dep in main_deps:
                    name, version, extras = parse_dependency_spec(dep)
                    print(f"üìã Parsed main dep '{dep}' -> name='{name}', version='{version}', extras='{extras}'", file=sys.stderr)
                    if name and version:
                        dependencies.append((name, version))
                        if extras:
                            packages_with_extras.append((name, version, extras))
                
                # Get optional dependencies (azure, broker groups) - include ALL for complete installation
                optional_deps = data.get('project', {}).get('optional-dependencies', {})
                print(f"üìã Available optional dependency groups: {list(optional_deps.keys())}", file=sys.stderr)
                
                # Include ALL optional dependency groups for complete functionality
                for group_name, group_deps in optional_deps.items():
                    print(f"üìã Processing {group_name} dependencies: {group_deps}", file=sys.stderr)
                    for dep in group_deps:
                        name, version, extras = parse_dependency_spec(dep)
                        print(f"üìã Parsed {group_name} dep '{dep}' -> name='{name}', version='{version}', extras='{extras}'", file=sys.stderr)
                        if name and version:
                            # Avoid duplicates
                            if (name, version) not in dependencies:
                                dependencies.append((name, version))
                            if extras and (name, version, extras) not in packages_with_extras:
                                packages_with_extras.append((name, version, extras))
                
                return dependencies, packages_with_extras
                
            except Exception as e:
                print(f"Error parsing pyproject.toml: {e}", file=sys.stderr)
                return [], []
        
        def resolve_dependencies_dynamically():
            """Create a temp venv, install packages, and get complete dependency list"""
            try:
                print("üîß Creating temporary virtual environment to resolve dependencies...", file=sys.stderr)
                
                # Create temporary directory
                with tempfile.TemporaryDirectory() as temp_dir:
                    venv_path = Path(temp_dir) / "temp_venv"
                    
                    # Create virtual environment
                    print(f"üìÅ Creating venv at: {venv_path}", file=sys.stderr)
                    subprocess.run([sys.executable, "-m", "venv", str(venv_path)], check=True)
                    
                    # Get the python executable path for the venv
                    if os.name == 'nt':  # Windows
                        python_exe = venv_path / "Scripts" / "python.exe"
                        pip_exe = venv_path / "Scripts" / "pip.exe"
                    else:  # Unix/Linux/macOS
                        python_exe = venv_path / "bin" / "python"
                        pip_exe = venv_path / "bin" / "pip"
                    
                    print(f"üêç Using Python: {python_exe}", file=sys.stderr)
                    print(f"üì¶ Using pip: {pip_exe}", file=sys.stderr)
                    
                    # Upgrade pip in the venv
                    subprocess.run([str(pip_exe), "install", "--upgrade", "pip"], 
                                 check=True, capture_output=True, text=True)
                    
                    # Install from pyproject.toml with azure and broker extras
                    print("üì¶ Installing from pyproject.toml with [azure,broker] extras...", file=sys.stderr)
                    
                    # Install with both azure and broker extras to get complete dependency tree
                    install_cmd = [str(pip_exe), "install", "-e", ".[azure,broker]"]
                    print(f"üî® Running: {' '.join(install_cmd)}", file=sys.stderr)
                    result = subprocess.run(install_cmd, capture_output=True, text=True, cwd=".")
                    
                    if result.returncode != 0:
                        print(f"‚ö†Ô∏è  Installation with extras failed, trying alternative approach...", file=sys.stderr)
                        print(f"Error stdout: {result.stdout}", file=sys.stderr)
                        print(f"Error stderr: {result.stderr}", file=sys.stderr)
                        
                        # Fallback: install base package first, then extras
                        print("üîÑ Trying step-by-step installation...", file=sys.stderr)
                        
                        # Install base package
                        base_cmd = [str(pip_exe), "install", "-e", "."]
                        print(f"üî® Installing base: {' '.join(base_cmd)}", file=sys.stderr)
                        base_result = subprocess.run(base_cmd, capture_output=True, text=True, cwd=".")
                        
                        if base_result.returncode != 0:
                            print(f"‚ùå Base installation failed: {base_result.stderr}", file=sys.stderr)
                            return None
                        
                        # Install optional dependencies manually from pyproject.toml
                        print("üìã Installing optional dependencies from pyproject.toml...", file=sys.stderr)
                        with open('pyproject.toml', 'rb') as f:
                            data = tomli.load(f)
                        
                        optional_deps = data.get('project', {}).get('optional-dependencies', {})
                        
                        # Install azure dependencies
                        if 'azure' in optional_deps:
                            for dep in optional_deps['azure']:
                                try:
                                    print(f"üî® Installing azure dep: {dep}", file=sys.stderr)
                                    subprocess.run([str(pip_exe), "install", dep], 
                                                 check=True, capture_output=True, text=True)
                                except subprocess.CalledProcessError as e:
                                    print(f"‚ö†Ô∏è  Failed to install azure dep {dep}: {e}", file=sys.stderr)
                        
                        # Install broker dependencies
                        if 'broker' in optional_deps:
                            for dep in optional_deps['broker']:
                                try:
                                    print(f"ÔøΩ Installing broker dep: {dep}", file=sys.stderr)
                                    subprocess.run([str(pip_exe), "install", dep], 
                                                 check=True, capture_output=True, text=True)
                                except subprocess.CalledProcessError as e:
                                    print(f"‚ö†Ô∏è  Failed to install broker dep {dep}: {e}", file=sys.stderr)
                    else:
                        print("‚úÖ Installation with extras successful!", file=sys.stderr)
                    
                    # Get list of installed packages
                    print("üìã Getting list of installed packages...", file=sys.stderr)
                    list_result = subprocess.run([str(pip_exe), "list", "--format=json"], 
                                                capture_output=True, text=True, check=True)
                    
                    installed_packages = json.loads(list_result.stdout)
                    print(f"‚úÖ Found {len(installed_packages)} installed packages", file=sys.stderr)
                    
                    # Filter out system packages and get only relevant ones
                    relevant_packages = []
                    exclude_packages = {'pip', 'setuptools', 'wheel', 'mycli-app-naga'}
                    
                    for pkg in installed_packages:
                        pkg_name = pkg['name'].lower()
                        if pkg_name not in exclude_packages and not pkg_name.startswith('_'):
                            relevant_packages.append((pkg['name'], pkg['version']))
                            print(f"üì¶ Including: {pkg['name']} v{pkg['version']}", file=sys.stderr)
                    
                    print(f"‚úÖ Filtered to {len(relevant_packages)} relevant packages", file=sys.stderr)
                    return relevant_packages
                    
            except Exception as e:
                print(f"‚ùå Error in dynamic dependency resolution: {e}", file=sys.stderr)
                print("üîÑ Falling back to pyproject.toml parsing...", file=sys.stderr)
                return None
        
        def parse_dependency_spec(dep_spec):
            """Parse dependency specification like 'click>=8.0.0' or 'azure-identity>=1.12.0' or 'msal[broker]>=1.20.0,<2'"""
            extras = None
            
            # First, handle extras by extracting the base package name and extras
            if '[' in dep_spec:
                # Extract package name and extras: 'msal[broker]>=1.20.0,<2' -> 'msal', 'broker', '>=1.20.0,<2'
                match = re.match(r'^([^[]+)\[([^\]]+)\](.*)$', dep_spec)
                if match:
                    base_name = match.group(1).strip()
                    extras = match.group(2).strip()
                    version_part = match.group(3).strip()
                    
                    print(f"üîç Parsing extras: '{dep_spec}' -> base='{base_name}', extras='{extras}', version='{version_part}'", file=sys.stderr)
                    
                    # Now parse the version part (handle constraints like >=1.20.0,<2)
                    if '>=' in version_part:
                        version = version_part.split('>=')[1].split(',')[0].strip()
                        return base_name, version, extras
                    elif '==' in version_part:
                        version = version_part.split('==')[1].split(',')[0].strip()
                        return base_name, version, extras
                    elif '>' in version_part:
                        version = version_part.split('>')[1].split(',')[0].strip()
                        return base_name, version, extras
                    else:
                        # No version specified with extras, use latest
                        print(f"üîç No version constraint found, using 'latest' for {base_name}[{extras}]", file=sys.stderr)
                        return base_name, "latest", extras
            
            # Handle normal dependencies without extras
            if '>=' in dep_spec:
                name, version = dep_spec.split('>=', 1)
                return name.strip(), version.split(',')[0].strip(), None  # Handle comma-separated constraints
            elif '==' in dep_spec:
                name, version = dep_spec.split('==', 1)
                return name.strip(), version.split(',')[0].strip(), None
            elif '>' in dep_spec:
                name, version = dep_spec.split('>', 1)
                return name.strip(), version.split(',')[0].strip(), None
            else:
                # Just package name, get latest
                return dep_spec.strip(), "latest", None
        
        def get_package_info(package_name, version_spec):
            """Get PyPI package download URL and SHA256 hash for latest compatible version"""
            try:
                # For version specs like ">=1.12.0" or "latest", get the latest version
                if version_spec == "latest" or version_spec.startswith('>=') or version_spec.startswith('>'):
                    # Get package info to find latest version
                    url = f"https://pypi.org/pypi/{package_name}/json"
                    response = requests.get(url)
                    if response.status_code != 200:
                        print(f"Error fetching {package_name}: {response.status_code}", file=sys.stderr)
                        return None, None, None
                    
                    data = response.json()
                    latest_version = data['info']['version']
                else:
                    # Use exact version
                    latest_version = version_spec.strip('=')
                
                # Get specific version info
                url = f"https://pypi.org/pypi/{package_name}/{latest_version}/json"
                response = requests.get(url)
                if response.status_code != 200:
                    print(f"Error fetching {package_name} {latest_version}: {response.status_code}", file=sys.stderr)
                    return None, None, None
                
                data = response.json()
                
                # Find source distribution
                for file_info in data['urls']:
                    if file_info['packagetype'] == 'sdist':
                        return file_info['url'], file_info['digests']['sha256'], latest_version
                
                # Special handling for binary-wheel packages like pymsalruntime
                # These packages are platform-specific and should be installed dynamically by pip
                if package_name == 'pymsalruntime':
                    print(f"üîç {package_name} is a platform-specific binary wheel package", file=sys.stderr)
                    print(f"   Will be installed dynamically during formula build (not as a resource)", file=sys.stderr)
                    # Skip this package - it will be installed via pip install during build
                    return None, None, None
                else:
                    print(f"No source distribution found for {package_name} {latest_version}", file=sys.stderr)
                return None, None, None
                
            except Exception as e:
                print(f"Error processing {package_name}: {e}", file=sys.stderr)
                return None, None, None
        
        def get_extra_dependencies(package_name, version, extras):
            """Get additional dependencies for a package with extras like msal[broker]"""
            try:
                print(f"üîç Getting extra dependencies for {package_name}[{extras}] {version}...", file=sys.stderr)
                
                url = f"https://pypi.org/pypi/{package_name}/{version}/json"
                response = requests.get(url)
                if response.status_code != 200:
                    print(f"Error fetching {package_name} {version} metadata: {response.status_code}", file=sys.stderr)
                    return []
                
                data = response.json()
                
                # Get the requires_dist field which contains dependency information
                requires_dist = data.get('info', {}).get('requires_dist', [])
                if not requires_dist:
                    print(f"No requires_dist found for {package_name}", file=sys.stderr)
                    return []
                
                print(f"üìã Found {len(requires_dist)} total requirements for {package_name}", file=sys.stderr)
                
                extra_deps = []
                for req in requires_dist:
                    # Look for dependencies with the specific extra (flexible matching)
                    # Examples: 
                    # 'pymsalruntime ; extra == "broker"'
                    # 'pymsalruntime ; (python_version >= "3.6") and extra == "broker"'
                    if f"extra == '{extras}'" in req or f'extra == "{extras}"' in req:
                        # Extract the package name from the requirement
                        dep_name = req.split(';')[0].strip()
                        # Remove version constraints and any extra characters, just get the package name
                        dep_name = re.split(r'[<>=!(\s]', dep_name)[0].strip()
                        if dep_name:  # Make sure we got a valid name
                            extra_deps.append(dep_name)
                            print(f"üì¶ Found extra dependency: {dep_name} (for {extras}) from: {req[:80]}...", file=sys.stderr)
                
                print(f"‚úì Found {len(extra_deps)} extra dependencies for {package_name}[{extras}]", file=sys.stderr)
                return extra_deps
                
            except Exception as e:
                print(f"Error getting extra dependencies for {package_name}[{extras}]: {e}", file=sys.stderr)
                return []
        
        # Prioritize dynamic dependency resolution from pyproject.toml
        print("üöÄ Starting dynamic dependency resolution from pyproject.toml...", file=sys.stderr)
        dynamic_deps = resolve_dependencies_dynamically()
        
        if dynamic_deps and len(dynamic_deps) >= 5:  # Accept if we have at least 5 dependencies
            print(f"‚úÖ Dynamic resolution successful! Found {len(dynamic_deps)} dependencies", file=sys.stderr)
            dependencies = dynamic_deps
            packages_with_extras = []  # Extras are already resolved in the complete list
        else:
            print("üîÑ Dynamic resolution failed or insufficient dependencies, using pyproject.toml parsing...", file=sys.stderr)
            # Parse dependencies from pyproject.toml (fallback)
            result = parse_pyproject_toml()
            if isinstance(result, tuple):
                dependencies, packages_with_extras = result
            else:
                # Fallback for old format
                dependencies = result
                packages_with_extras = []
        
        # Only use hardcoded fallback if we have very few dependencies (less than 3)
        if not dependencies or len(dependencies) < 3:
            print(f"‚ùå Insufficient dependencies found ({len(dependencies) if dependencies else 0}), using hardcoded complete list", file=sys.stderr)
            # Fallback to hardcoded dependencies with broker support
            dependencies = [
                ("click", "8.1.7"),
                ("colorama", "0.4.6"),
                ("azure-identity", "1.17.1"),
                ("azure-core", "1.30.0"),
                ("azure-mgmt-core", "1.4.0"),
                ("msal", "1.31.0"),
                ("msal-extensions", "1.3.1"),  # Broker support
                ("pymsalruntime", "0.18.1"),  # Key broker dependency - CRITICAL for native authentication
                ("requests", "2.32.3"),
                ("certifi", "2024.8.30"),
                ("charset-normalizer", "3.3.2"),
                ("idna", "3.8"),
                ("urllib3", "2.2.3"),
                ("six", "1.16.0"),
                ("cryptography", "43.0.1"),
                ("cffi", "1.17.1"),  # Required for cryptography
                ("pycparser", "2.22"),  # Required for cffi
                ("PyJWT", "2.9.0"),  # Required for MSAL
                ("typing_extensions", "4.12.2"),  # Python compatibility
            ]
            packages_with_extras = []
        else:
            # We have some dependencies, but ensure critical broker dependencies are included
            broker_deps_needed = ["msal", "azure-identity", "azure-core", "msal-extensions", "pymsalruntime"]
            missing_broker_deps = []
            
            for broker_dep in broker_deps_needed:
                if not any(dep[0] == broker_dep for dep in dependencies):
                    missing_broker_deps.append(broker_dep)
            
            if missing_broker_deps:
                print(f"‚ö†Ô∏è  Missing critical broker dependencies: {missing_broker_deps}", file=sys.stderr)
                print("üîê Adding missing broker dependencies for complete authentication support", file=sys.stderr)
                
                # Add missing broker dependencies with latest versions
                for missing_dep in missing_broker_deps:
                    dependencies.append((missing_dep, "latest"))
                    print(f"‚ûï Added missing dependency: {missing_dep}", file=sys.stderr)
            
            # Ensure pymsalruntime is present for broker support
            if not any(dep[0] == "pymsalruntime" for dep in dependencies):
                print("‚ö†Ô∏è  pymsalruntime missing, adding for broker support", file=sys.stderr)
                dependencies.append(("pymsalruntime", "latest"))
                print("‚úÖ Added pymsalruntime for broker authentication support", file=sys.stderr)
        
        print(f"üìã Final dependency count: {len(dependencies)}", file=sys.stderr)
        print(f"üéØ Packages with extras to process: {len(packages_with_extras)}", file=sys.stderr)
        
        # Process extra dependencies only if we're using pyproject.toml parsing
        # (dynamic resolution already includes all transitive dependencies)
        if packages_with_extras:
            print("üîç Processing extra dependencies from pyproject.toml parsing...", file=sys.stderr)
            for package_name, version, extras in packages_with_extras:
                print(f"üîç Processing extras for {package_name}[{extras}] {version}...", file=sys.stderr)
                extra_deps = get_extra_dependencies(package_name, version, extras)
                for extra_dep in extra_deps:
                    # Add the extra dependency with "latest" version if not already present
                    if not any(dep[0] == extra_dep for dep in dependencies):
                        dependencies.append((extra_dep, "latest"))
                        print(f"‚ûï Added extra dependency: {extra_dep}", file=sys.stderr)
                    else:
                        print(f"‚è≠Ô∏è  Extra dependency {extra_dep} already present", file=sys.stderr)
        else:
            print("‚ÑπÔ∏è  Using complete dependency list (no extra processing needed)", file=sys.stderr)
        
        resources = []
        for name, version in dependencies:
            print(f"üîç Processing {name} {version}...", file=sys.stderr)
            
            # For dynamic resolution, version is actual version, for parsing it might be "latest" or ">=X.Y.Z"
            if version == "latest" or version.startswith('>=') or version.startswith('>'):
                url, sha256, actual_version = get_package_info(name, version)
            else:
                # Version is already resolved, just get the download info for this specific version
                url, sha256, actual_version = get_package_info(name, f"=={version}")
            
            if url and sha256:
                resources.append({
                    'name': name,
                    'url': url,
                    'sha256': sha256,
                    'version': actual_version
                })
                print(f"‚úì {name} {actual_version}: {sha256[:16]}...", file=sys.stderr)
            else:
                print(f"‚úó Failed to get info for {name} {version}", file=sys.stderr)
        
        # Output as JSON
        print(json.dumps(resources))
        EOF
        
        # Run the script and capture output
        echo "üöÄ Starting dependency resolution..."
        DEPS_JSON=$(python3 get_deps.py 2>/dev/null)
        if [[ $? -ne 0 ]] || [[ -z "$DEPS_JSON" ]]; then
          echo "‚ùå Python script failed, checking stderr output..."
          python3 get_deps.py
          exit 1
        fi
        
        echo "dependencies_json<<EOF" >> $GITHUB_OUTPUT
        echo "$DEPS_JSON" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "‚úÖ Collected dependency information"
    
    - name: Verify collected dependencies
      run: |
        echo "üìã Verification: Checking collected dependencies..."
        
        # Parse the collected dependencies JSON to verify what we gathered
        DEPS_JSON='${{ steps.get_dependencies.outputs.dependencies_json }}'
        
        echo "üì¶ Dependencies that will be included in the formula:"
        echo "$DEPS_JSON" | python3 -c "
        import json
        import sys
        
        try:
            deps = json.load(sys.stdin)
            print(f'Total dependencies: {len(deps)}')
            print('=' * 50)
            for i, dep in enumerate(deps, 1):
                print(f'{i:2d}. {dep[\"name\"]:20} v{dep[\"version\"]:15} SHA: {dep[\"sha256\"][:16]}...')
            print('=' * 50)
            
            # Check for specific broker-related packages
            broker_packages = ['msal', 'pymsalruntime', 'azure-identity', 'msal-extensions']
            print('üîç Broker functionality packages:')
            for pkg in broker_packages:
                found = next((d for d in deps if d['name'] == pkg), None)
                if found:
                    print(f'  ‚úÖ {pkg}: v{found[\"version\"]}')
                else:
                    print(f'  ‚ùå {pkg}: NOT FOUND')
            
            # Check for critical broker dependency
            pymsalruntime_found = next((d for d in deps if d['name'] == 'pymsalruntime'), None)
            if pymsalruntime_found:
                print(f'\\nüîê ‚úÖ BROKER SUPPORT: pymsalruntime v{pymsalruntime_found[\"version\"]} found!')
                print('    This enables native broker authentication on supported platforms.')
                print('    Using AWS CLI-style selective pip install for binary wheel dependency.')
            else:
                print('\\nüîê ‚ö†Ô∏è  pymsalruntime not found in dependency resolution.')
                print('    Will be added to fallback dependencies for broker support.')
            
            # Show URL sources for verification
            print()
            print('üåê Package sources:')
            for dep in deps:
                source_type = 'PyPI' if 'files.pythonhosted.org' in dep['url'] else 'Other'
                print(f'  ‚Ä¢ {dep[\"name\"]}: {source_type}')
                
        except Exception as e:
            print(f'Error parsing dependencies: {e}')
            sys.exit(1)
        "
        
        echo ""
        echo "üîç Checking if pyproject.toml broker extras are properly handled..."
        
        # Show the broker dependencies from pyproject.toml for comparison
        python3 -c "
        import tomli
        
        try:
            with open('pyproject.toml', 'rb') as f:
                data = tomli.load(f)
            
            broker_deps = data.get('project', {}).get('optional-dependencies', {}).get('broker', [])
            print('üìã Broker dependencies from pyproject.toml:')
            for dep in broker_deps:
                print(f'  ‚Ä¢ {dep}')
            
            if 'msal[broker]' in str(broker_deps):
                print('‚úÖ msal[broker] found in pyproject.toml - extras should be handled')
            else:
                print('‚ÑπÔ∏è  No msal[broker] found, checking for msal with broker extras...')
                
        except Exception as e:
            print(f'Error reading pyproject.toml: {e}')
        "
        
        echo ""
        echo "‚úÖ Dependency verification completed"
    
    - name: Checkout Homebrew tap repository
      uses: actions/checkout@v4
      with:
        repository: naga-nandyala/homebrew-mycli-app
        token: ${{ secrets.HOMEBREW_TAP_TOKEN || secrets.GITHUB_TOKEN }}
        path: homebrew-tap
        
    - name: Update Homebrew formula for source installation
      run: |
        cd homebrew-tap
        
        VERSION="${{ steps.get_release.outputs.version }}"
        SOURCE_SHA="${{ steps.calculate_hash.outputs.source_sha }}"
        
        # Create Formula directory if it doesn't exist
        mkdir -p Formula
        
        # Parse dependencies JSON
        DEPS_JSON='${{ steps.get_dependencies.outputs.dependencies_json }}'
        
        # Generate resource blocks
        python3 << EOF > resources.rb
        import json
        
        deps_json = '''$DEPS_JSON'''
        dependencies = json.loads(deps_json)
        
        for dep in dependencies:
            print(f'''  resource "{dep['name']}" do
            url "{dep['url']}"
            sha256 "{dep['sha256']}"
          end
        ''')
        EOF
        
        # Create the complete formula
        cat > Formula/mycli-app-src.rb << EOF
        # Homebrew formula for mycli-app (source-based installation)
        class MycliAppSrc < Formula
          include Language::Python::Virtualenv

          desc "Simple Azure-like CLI tool by Naga (Source Installation)"
          homepage "https://github.com/naga-nandyala/mycli-app"
          url "https://github.com/naga-nandyala/mycli-app/archive/refs/tags/v$VERSION.tar.gz"
          sha256 "$SOURCE_SHA"
          license "MIT"
          head "https://github.com/naga-nandyala/mycli-app.git", branch: "main"

          livecheck do
            url :stable
            regex(/^v?(\d+(?:\.\d+)+)$/i)
            strategy :github_latest
          end

          bottle do
            # Homebrew will generate these automatically when building bottles
          end

          depends_on "python@3.12"

          # Build dependencies for cryptography
          depends_on "rust" => :build
          depends_on "pkgconf" => :build
          depends_on "openssl@3"

          uses_from_macos "libffi"

        EOF
        
        # Append resource blocks
        cat resources.rb >> Formula/mycli-app-src.rb
        
        # Append the rest of the formula
        cat >> Formula/mycli-app-src.rb << 'EOF'

          def install
            # Ensure that the `openssl` crate picks up the intended library for cryptography
            ENV["OPENSSL_DIR"] = Formula["openssl@3"].opt_prefix
            ENV["OPENSSL_NO_VENDOR"] = "1"

            # Create virtual environment
            venv = virtualenv_create(libexec, "python3.12", system_site_packages: false)
            
            # Install all dependencies from resources
            # (pymsalruntime is excluded from resources and handled separately)
            venv.pip_install resources

            # Install pymsalruntime separately using pip with automatic platform detection
            # This allows pip to select the correct wheel for the target platform
            system venv.root/"bin/pip", "install", "pymsalruntime", exception: true

            # Install the main application
            venv.pip_install buildpath

            # Create the CLI wrapper script using proper entry point
            (bin/"mycli").write <<~SHELL
              #!/usr/bin/env bash
              exec "#{libexec}/bin/mycli" "$@"
            SHELL

            # Generate shell completions if supported
            # generate_completions_from_executable(bin/"mycli", "--completion", base_name: "mycli")
          end

          test do
            # Test basic functionality
            assert_match version.to_s, shell_output("#{bin}/mycli --version")
            
            # Test help command
            help_output = shell_output("#{bin}/mycli --help")
            assert_match "Usage:", help_output
            
            # Test Azure-related functionality is available
            assert_match "azure", help_output.downcase
          end

          def caveats
            <<~EOS
              This is the source-based installation of mycli-app with full broker authentication support.
              Built using the AWS CLI approach for handling binary wheel dependencies.
              
              üéØ Features:
              - Built from source for maximum compatibility
              - Dependencies managed by Homebrew
              - Full Azure authentication including native broker support
              - Automatic updates through Homebrew
              
              üîê Authentication Methods Available:
              - Browser-based authentication (default)
              - Device code authentication (--use-device-code)
              - Native broker authentication with pymsalruntime
              - Microsoft Company Portal integration
              - Touch ID/Face ID support on macOS (where available)
              - MSAL token caching and refresh
              
              ‚ú® Technical Implementation:
              - Uses dynamic pip install for platform-specific binary wheels
              - Source dependencies built from PyPI source distributions
              - pymsalruntime installed with automatic platform detection
              - Follows Homebrew best practices for mixed dependency types
              
              üì± Available authentication commands:
                mycli login                    # Browser authentication (default)
                mycli login --device           # Device code authentication  
                mycli login --use-broker       # Native broker authentication
                
              ÔøΩ Alternative Installation:
              For a pre-built venv bundle approach:
                brew install naga-nandyala/mycli-app/mycli-app-venv
                
              For more information, visit:
                https://github.com/naga-nandyala/mycli-app
            EOS
          end
        end
        EOF
        
        echo "‚úÖ Source-based formula updated with version $VERSION"
        echo "Source SHA256: $SOURCE_SHA"
        
        # Clean up temporary files
        rm -f resources.rb
        
        # Debug: Show the created file
        echo "üìã Created formula file:"
        ls -la Formula/mycli-app-src.rb
        echo "üìã Formula file preview:"
        head -30 Formula/mycli-app-src.rb
        echo "..."
        tail -10 Formula/mycli-app-src.rb
        
    - name: Commit and push formula update
      run: |
        cd homebrew-tap
        
        # Configure git
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        # Debug: Show current state
        echo "üìã Current directory and files:"
        pwd
        ls -la
        echo "üìã Formula directory:"
        ls -la Formula/
        
        # Check if there are changes (including untracked files)
        echo "üìã Git status:"
        git status --porcelain
        if [[ -z "$(git status --porcelain)" ]]; then
          echo "No changes to commit"
          exit 0
        fi
        
        VERSION="${{ steps.get_release.outputs.version }}"
        
        # Create commit message
        if [ "${{ github.event_name }}" = "release" ]; then
          COMMIT_MSG="Update mycli-app-src to version $VERSION (source installation)

        Released: ${{ github.event.release.tag_name }}
        - Source SHA256: ${{ steps.calculate_hash.outputs.source_sha }}
        
        This release uses the source-based approach with dynamic platform-specific dependency handling.
        Features:
        - Built from source for maximum compatibility
        - Dependencies managed by Homebrew's virtualenv system
        - Full broker authentication support with pymsalruntime
        - Dynamic pip install for platform-specific binary wheels
        - Automatic security updates for dependencies
        
        Technical implementation uses dynamic pip install for platform-specific packages.
        
        Automated update from release workflow"
        else
          COMMIT_MSG="Update mycli-app-src to version $VERSION (source installation)

        - Source SHA256: ${{ steps.calculate_hash.outputs.source_sha }}
        
        This release uses the source-based approach with dynamic platform-specific dependency handling.
        Features:
        - Built from source for maximum compatibility
        - Dependencies managed by Homebrew's virtualenv system
        - Full broker authentication support with pymsalruntime
        - Dynamic pip install for platform-specific binary wheels
        - Automatic security updates for dependencies
        
        Technical implementation uses dynamic pip install for platform-specific packages.
        
        Automated update (manual trigger)"
        fi
        
        # Commit and push changes
        git add Formula/mycli-app-src.rb
        git commit -m "$COMMIT_MSG"
        git push origin main
        
        echo "‚úÖ Homebrew tap updated successfully for source installation!"
      env:
        GITHUB_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN || secrets.GITHUB_TOKEN }}